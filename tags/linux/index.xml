<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 項 思 偉 ~ Aal Izz Well!</title>
    <link>https://daveixiang.github.io/tags/linux/</link>
    <description>Recent content in Linux on 項 思 偉 ~ Aal Izz Well!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Jun 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://daveixiang.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LSI MegaRaid Monitor Linux</title>
      <link>https://daveixiang.github.io/articles/2017_06_02_lsi_megaraid_monitor_linux/</link>
      <pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_06_02_lsi_megaraid_monitor_linux/</guid>
      <description> Installl MegaCLI tools  unzip 8.07.10_MegaCLI_Linux.zip cd 8.07.10_MegaCLI_Linux rpm2cpio MegaCli-8.07.10-1.noarch.rpm | cpio -idmv cd opt &amp;amp;&amp;amp; mv MegaRAID /opt /opt/MegaRAID/MegaCli/MegaCli64 -AdpAllInfo -aALL   Command reference  MegaCli64 -adpCount MegaCli64 -AdpGetTime –aALL MegaCli64 -AdpAllInfo -aAll MegaCli64 -LDInfo -LALL -aAll MegaCli64 -PDList -aAll MegaCli64 -AdpBbuCmd -GetBbuStatus -aALL MegaCli64 -AdpBbuCmd -GetBbuCapacityInfo -aALL MegaCli64 -AdpBbuCmd -GetBbuDesignInfo -aALL MegaCli64 -AdpBbuCmd -GetBbuProperties -aALL MegaCli64 -cfgdsply -aALL  </description>
    </item>
    
    <item>
      <title>Linux: How to bind IP that doesn&#39;t exist</title>
      <link>https://daveixiang.github.io/articles/2017_05_27_linux_how_to_bind_ip_that_does_not_exist/</link>
      <pubDate>Sat, 27 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_05_27_linux_how_to_bind_ip_that_does_not_exist/</guid>
      <description>This tip is really usefull if you use virtual ips.
Imagine you are using keepalived + haproxy on your loadbalancers in active/active mode.
You have 2 virtual IPs one is on the first load balancer and the other is on the second.
Now in your haproxy.cfg you have to bind these IPs, the probem is that one of the virtual IPs is not on the current loadbalancer, so haproxy will refuse to start with the following error: cannot bind socket.</description>
    </item>
    
    <item>
      <title>linux pci device driver using mmio demo</title>
      <link>https://daveixiang.github.io/articles/2017_04_25_linux_pci_device_driver_using_mmio_demo/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_04_25_linux_pci_device_driver_using_mmio_demo/</guid>
      <description>The pci driver is written to drive the qemu pci-helloworld device
pci-helloworld driver source code  the driver code pci-helloworld  #include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/kernel.h&amp;gt; #include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/pci.h&amp;gt; #include &amp;lt;linux/printk.h&amp;gt; #include &amp;lt;linux/proc_fs.h&amp;gt; #include &amp;lt;linux/seq_file.h&amp;gt; MODULE_LICENSE(&amp;quot;GPL&amp;quot;); static struct pci_dev *_pdev; static void __iomem *_mmio; static const struct pci_device_id pcidevtbl[] = { { 0x6688, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, { } /* terminate */ }; void pci_helloworld_reset_pointer(void __iomem *mmio) { iowrite8(1, mmio + 1); } void pci_helloworld_set_buf_len(void __iomem *mmio, uint8_t len) { iowrite8(len, mmio + 2); } void pci_helloworld_write_char(void __iomem *mmio, char c) { iowrite8(c, mmio + 0); } static int pci_helloworld_show(struct seq_file *m, void *v) { int i, len; char *buf; if (!</description>
    </item>
    
    <item>
      <title>qemu pci device demo</title>
      <link>https://daveixiang.github.io/articles/2017_04_25_qemu_pci_device_demo/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_04_25_qemu_pci_device_demo/</guid>
      <description>Add the device source code {QEMU_SRC}/hw/misc/pci-helloworld.c #include &amp;quot;qemu/osdep.h&amp;quot; #include &amp;quot;hw/hw.h&amp;quot; #include &amp;quot;hw/pci/pci.h&amp;quot; #include &amp;quot;qemu/event_notifier.h&amp;quot; typedef struct PCIHelloWorldDevState { PCIDevice parent_obj; int pos; char *buf; int buflen; MemoryRegion mmio; } PCIHelloWorldDevState; #define TYPE_PCI_HELLOWORLD_DEV &amp;quot;pci-helloworld&amp;quot; #define PCI_HELLOWORLD_DEV(obj) \ OBJECT_CHECK(PCIHelloWorldDevState, (obj), TYPE_PCI_HELLOWORLD_DEV) static uint64_t pci_helloworld_dev_mmio_read(void *opaque, hwaddr addr, unsigned size) { PCIHelloWorldDevState *d = opaque; if (addr == 0) return d-&amp;gt;buf[d-&amp;gt;pos ++]; else return d-&amp;gt;buflen; } static void pci_helloworld_dev_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned size) { PCIHelloWorldDevState *d = opaque; switch(addr) { case 0: /* write byte */ if (!</description>
    </item>
    
    <item>
      <title>Build minimal linux hack env with busybox (Target: x86_64)</title>
      <link>https://daveixiang.github.io/articles/2017_04_01_build_minimal_linux_hack_env_with_busybox_x86_64/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_04_01_build_minimal_linux_hack_env_with_busybox_x86_64/</guid>
      <description>Build the kernel  Use x86_64 default configuration  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- defconfig   Simplify x86_64 configuration by cutting unused drivers  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- menuconfig   Create Image  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- -j8  Build busybox  Use busybox default configuration  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- defconfig   Customize configurations  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- menuconfig  Busybox Settings ---&amp;gt; --- Build Options [*] Build BusyBox as a position independent executable   Create busybox  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- -j$(nproc)   Install busybox(default path: BUSYBOX/_install)  make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- install  Generate minimal initramfs #!</description>
    </item>
    
    <item>
      <title>Netlink hello world example</title>
      <link>https://daveixiang.github.io/articles/2017_03_31_netlink_hello_world_example/</link>
      <pubDate>Fri, 31 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_31_netlink_hello_world_example/</guid>
      <description>demo kernel code  hello_nl_kern.c  #include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;net/sock.h&amp;gt; #include &amp;lt;linux/netlink.h&amp;gt; #include &amp;lt;linux/skbuff.h&amp;gt; #define NETLINK_USER 31 struct sock *nl_sk = NULL; static void hello_nl_recv_msg(struct sk_buff *skb) { struct nlmsghdr *nlh; int pid; struct sk_buff *skb_out; int msg_size; char *msg = &amp;quot;Hello from kernel&amp;quot;; int res; printk(KERN_INFO &amp;quot;Entering: %s\n&amp;quot;, __FUNCTION__); msg_size = strlen(msg); nlh = (struct nlmsghdr *)skb-&amp;gt;data; printk(KERN_INFO &amp;quot;Netlink received msg payload: %s\n&amp;quot;,(char*)nlmsg_data(nlh)); pid = nlh-&amp;gt;nlmsg_pid; skb_out = nlmsg_new(msg_size,0); if (!</description>
    </item>
    
    <item>
      <title>How to get the complete and exact list of mounted filesystems in Linux?</title>
      <link>https://daveixiang.github.io/articles/2017_03_22_get_the_complete_and_exact_list_of_mounted_filesystems_in_linux/</link>
      <pubDate>Wed, 22 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_22_get_the_complete_and_exact_list_of_mounted_filesystems_in_linux/</guid>
      <description>findmnt -lo source,target,fstype,label,options,used -t xfs  SOURCE TARGET FSTYPE LABEL OPTIONS /dev/vda1 / xfs rw,relatime,attr2,inode64,noquota  /proc/mounts /etc/mtab  </description>
    </item>
    
    <item>
      <title>Install Openstack from source code - glance (mitaka)</title>
      <link>https://daveixiang.github.io/articles/2017_03_21_openstack_from_source_code_mitaka_02_glance/</link>
      <pubDate>Tue, 21 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_21_openstack_from_source_code_mitaka_02_glance/</guid>
      <description>Create image service database export GLANCE_DBPASS=openstack export MYSQL_PASS=openstack mysql -uroot -p$MYSQL_PASS &amp;lt;&amp;lt;EOF CREATE DATABASE glance; GRANT ALL PRIVILEGES ON glance.* TO &#39;glance&#39;@&#39;localhost&#39; \ IDENTIFIED BY &#39;$GLANCE_DBPASS&#39;; GRANT ALL PRIVILEGES ON glance.* TO &#39;glance&#39;@&#39;%&#39; \ IDENTIFIED BY &#39;$GLANCE_DBPASS&#39;; EOF  Create the image service credentials andAPI endpoints openstack user create --domain default --password openstack glance openstack role add --project service --user glance admin openstack service create --name glance --description &amp;quot;OpenStack Image&amp;quot; image openstack endpoint create --region RegionOne image public http://controller:9292 openstack endpoint create --region RegionOne image internal http://controller:9292 openstack endpoint create --region RegionOne image admin http://controller:9292  Install glance dependences yum install $(cat openstack-glance-deps.</description>
    </item>
    
    <item>
      <title>Install Openstack from source code - keystone (mitaka)</title>
      <link>https://daveixiang.github.io/articles/2017_03_04_openstack_from_source_code_mitaka_01_keystone/</link>
      <pubDate>Sat, 04 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_04_openstack_from_source_code_mitaka_01_keystone/</guid>
      <description>Install keystone dependences yum install $(cat openstack-keystone-deps.log | cut -d, -f1 | tr -s &#39;\n&#39; &#39; &#39;)  Git clone source code from github git clone https://github.com/openstack/keystone cd /src/openstack/keystone git checkout stable/mitaka  Build keystone source code cd /src/openstack/keystone python setup.py build  Make keystone configuration cp -aR etc/* /etc/keystone mv /etc/keystone/keystone.conf.sample /etc/keystone/keystone.conf mv /etc/keystone/logging.conf.sample /etc/keystone/logging.conf mkdir /etc/keystone/fernet-keys/ sed -i -E -e &#39;/^#.+?$/d&#39; -e &#39;/^$/d&#39; /etc/keystone/keystone.conf ini-config --set /etc/keystone/keystone.conf DEFAULT admin_token admintoken ini-config --set /etc/keystone/keystone.</description>
    </item>
    
    <item>
      <title>Install Openstack from source code dependences (mitaka)</title>
      <link>https://daveixiang.github.io/articles/2017_03_01_openstack_from_source_code_mitaka_00_dependences/</link>
      <pubDate>Wed, 01 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_01_openstack_from_source_code_mitaka_00_dependences/</guid>
      <description>#!/bin/bash function gen_pkg_deps() { [ -z &amp;quot;$@&amp;quot; ] &amp;amp;&amp;amp; exit 0; yum install --assumeno &amp;quot;$@&amp;quot; | \ sed -n &#39;/Installing for dependencies:/,/Transaction Summary/p&#39; | \ sed -e &#39;/^=.*?$/d&#39; \ -e &#39;/Installing:/d&#39; \ -e &#39;/Installing for dependencies:/d&#39; \ -e &#39;/Transaction Summary/d&#39; \ -e &#39;/Updating/d&#39; \ -e &#39;/^$/d&#39; | \ awk &#39;BEGIN {n=1;arr[0]=0} { if (NF != 6) { for (i=n; i&amp;lt;=n+NF-1;i++) arr[i] = $(i-n+1) n+=NF; if (n == 7) { printf &amp;quot;%s,%s,%s,%s\n&amp;quot;, arr[1], arr[2], arr[3], arr[4] for (i=1; i&amp;lt;n;i++) del arr[i] n=1 } } else { printf &amp;quot;%s,%s,%s,%s\n&amp;quot;, $1, $2, $3, $4 } }&#39; | sort | grep -v -E -e &#39;glance|keystone|nova|neutron|swift|cinder|ceilometer&#39;\ &amp;gt; &amp;quot;$@&amp;quot;-deps.</description>
    </item>
    
    <item>
      <title>Multiple ways to access QEMU Machine Protocol (QMP)</title>
      <link>https://daveixiang.github.io/articles/2017_02_28_multiple_ways_to_access_qmp/</link>
      <pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_28_multiple_ways_to_access_qmp/</guid>
      <description>QMP (QEMU Machine Protocol) is quiet useful. QMP allows applications to communicate withh a running QEMU&amp;rsquo;s instance. There ae a few different ways to access the QEMU monitor to query the guest&amp;rsquo;s information, modify the guest state using the QMP commands.
Access QMP via libvirt’s qemu-monitor-command virsh qemu-monitor-command ${domain-name} --pretty &#39;{&amp;quot;execute&amp;quot;:&amp;quot;query-kvm&amp;quot;}&#39;  QMP via tcp socket  launch an qemu instance:  qemu-system-x86_64 --enable-kvm -drive if=virtio,format=qcow2,index=0,file=cirros-0.3.5-x86_64-disk.img --qmp tcp:127.0.0.1:12345,server  and the output in the terminal like:</description>
    </item>
    
    <item>
      <title>Build minimal linux hack env with busybox (Target: arm64)</title>
      <link>https://daveixiang.github.io/articles/2017_02_25_build_minimal_linux_hack_env_with_busybox_arm64/</link>
      <pubDate>Sat, 25 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_25_build_minimal_linux_hack_env_with_busybox_arm64/</guid>
      <description>Build the kernel  Use arm64 default configuration  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig   Simplify arm64 configuration by cutting unused drivers  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig   Create Image  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8  Build busybox  Use busybox default configuration  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig   Customize configurations  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig  Busybox Settings ---&amp;gt; --- Build Options [*] Build BusyBox as a position independent executable   Create busybox  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc)   Install busybox(default path: BUSYBOX/_install)  make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- install  Generate minimal initramfs #!</description>
    </item>
    
    <item>
      <title>Install Openstack from source code prepares (mitaka)</title>
      <link>https://daveixiang.github.io/articles/2017_02_25_openstack_from_source_code_mitaka_00_prepares/</link>
      <pubDate>Sat, 25 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_25_openstack_from_source_code_mitaka_00_prepares/</guid>
      <description>Disable NetworkManager and enable network systemctl stop NetworkManager.service systemctl disable NetworkManager.service systemctl start network.service systemctl enable network.service  Disable SELinux sed -i &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39; /etc/selinux/config  Disable Firewalld systemctl stop firewalld systemctl disable firewalld  Disalbe YUM fast mirrors and language features sed -i -E -e &#39;s/enabled=1/enabled=0/&#39; /etc/yum/pluginconf.d/fastestmirror.conf sed -i -E -e &#39;s/enabled=1/enabled=0/&#39; /etc/yum/pluginconf.d/langpacks.conf  Speed up SSH connection sed -i &#39;s/#UseDNS yes/UseDNS no/&#39; /etc/ssh/sshd_config  Install and configure rabbitmq yum -y install rabbitmq-server systemctl start rabbitmq-server systemctl enable rabbitmq-server  rabbitmqctl add_user openstack openstack rabbitmqctl set_user_tags openstack administrator rabbitmqctl set_permissions -p / openstack &amp;quot;.</description>
    </item>
    
    <item>
      <title>Using OpenvSwitch to build minimal linux networking hack environment</title>
      <link>https://daveixiang.github.io/articles/2017_02_25_using_openvswitch_to_build_minimal_linux_networking_hack_env/</link>
      <pubDate>Sat, 25 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_25_using_openvswitch_to_build_minimal_linux_networking_hack_env/</guid>
      <description>Create Openvswitch bridge and two tap devices for vm ip tuntap add name tap01 mode tap ip tuntap add name tap02 mode tap ip link set tap01 up ip link set tap02 up ip link set tap01 address 12:34:56:78:9a:01 ip link set tap01 address 12:34:56:78:9a:02 ovs-vsctl add-br br0 ovs-vsctl add-port br0 tap01 ovs-vsctl add-port br0 tap02  Start the two vms and config network configure vm01  start vm01  qemu-system-x86_64 -m 2048M -enable-kvm \ -nographic \ -kernel .</description>
    </item>
    
    <item>
      <title>GCC inline assembly hello world example</title>
      <link>https://daveixiang.github.io/articles/2017_02_17_gcc_inline_assembly_hello_world_example/</link>
      <pubDate>Fri, 17 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_17_gcc_inline_assembly_hello_world_example/</guid>
      <description>x86 example  #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { char *str = &amp;quot;Hello World\n&amp;quot;; long len = strlen(str); int ret = 0; /* * ssize_t write(int fd, const void *buf, size_t count); * */ __asm__(&amp;quot;movl $1, %%eax\n\t&amp;quot; // write syscall &amp;quot;movl $1, %%ebx\n\t&amp;quot; // fd &amp;quot;movl %1, %%ecx\n\t&amp;quot; // buf &amp;quot;movl %2, %%edx\n\t&amp;quot; // count &amp;quot;syscall\n\t&amp;quot; &amp;quot;movl %%eax, %0&amp;quot; // return result to ret : &amp;quot;+m&amp;quot;(ret) : &amp;quot;g&amp;quot;(str), &amp;quot;g&amp;quot;(len)); printf(&amp;quot;ret %d\n&amp;quot;, ret); return 0; }   x86-64 example  #include &amp;lt;string.</description>
    </item>
    
    <item>
      <title>What is a system call (Linux)</title>
      <link>https://daveixiang.github.io/articles/2017_02_02_what_is_a_system_call_linux/</link>
      <pubDate>Thu, 02 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_02_what_is_a_system_call_linux/</guid>
      <description>An application program makes a system call to get the operating system to perform a service for it, like reading from a file.
System Calls in 32-bit Linux  To make a system call in 32-bit Linux, place the system call number in eax, then its arguments, in order, in ebx, ecx, edx, esi, edi, and ebp, then invoke int 0x80.
 Some system calls return information, usually in eax.</description>
    </item>
    
    <item>
      <title>Nested KVM</title>
      <link>https://daveixiang.github.io/articles/2016_09_03_nested_kvm/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2016_09_03_nested_kvm/</guid>
      <description> Enable the setting for Nested KVM  cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/modprobe.d/kvm-nested.conf options kvm_intel nested=1 EOF modprobe -r kvm_intel modprobe kvm_intel cat /sys/module/kvm_intel/parameters/nested   Edit the configuration of a virtual machine you&amp;rsquo;d want to set nested  virsh edit {DOMAIN_NAME}  and add the following setting to the vm configuration:
&amp;lt;cpu mode=&#39;host-passthrough&#39;&amp;gt; &amp;lt;/cpu&amp;gt;  </description>
    </item>
    
    <item>
      <title>Add Module to the Linux Kernel Source</title>
      <link>https://daveixiang.github.io/articles/2016_04_21_add_module_to_the_linux_kernel_source/</link>
      <pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2016_04_21_add_module_to_the_linux_kernel_source/</guid>
      <description>Create module directory Create a directory skm inside drivers (which is in the Linux source code) for your module and put source code(skm.c) into it. It will looks like:
{LINUX_SRC_PATH}/drivers/skm/skm.c  and the source code file skm.c appears like:
#include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/version.h&amp;gt; #include &amp;lt;linux/kernel.h&amp;gt; static int __init skm_init(void) { printk(KERN_INFO &amp;quot;Hello Kernel Space!\n&amp;quot;); return 0; } static void __exit skm_exit(void) { printk(KERN_INFO &amp;quot;Bye Kernel Space!\n&amp;quot;); } module_init(skm_init); module_exit(skm_exit); MODULE_LICENSE(&amp;quot;GPL&amp;quot;); MODULE_AUTHOR(&amp;quot;Xiang Davei&amp;quot;); MODULE_DESCRIPTION(&amp;quot;Simple Kernel Module&amp;quot;)  Create Makefile file Create one Makefile inside skm and add obj-$(CONFG_SKM) += skm.</description>
    </item>
    
    <item>
      <title>Linux Hello World Module</title>
      <link>https://daveixiang.github.io/articles/2016_04_20_linux_helloworld_module/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2016_04_20_linux_helloworld_module/</guid>
      <description>Source Code  #include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/kernel.h&amp;gt; #include &amp;lt;linux/sched.h&amp;gt; static __init int hwm_init(void) { /* do_this() */ /* do_that() */ /* do_something_else() */ printk(KERN_INFO &amp;quot;hwm module being loaded\n&amp;quot;); return 0; } static __exit void hwm_exit(void) { /* undo_something_else() */ /* undo_that() */ /* undo_this() */ printk(KERN_INFO &amp;quot;hwm module being unloaded\n&amp;quot;); } module_init(hwm_init); module_exit(hwm_exit); MODULE_AUTHOR(&amp;quot;davei&amp;quot;); MODULE_LICENSE(&amp;quot;GPL&amp;quot;); MODULE_DESCRIPTION(&amp;quot;Hello World Module&amp;quot;); MODULE_INFO(flavor, &amp;quot;Linux&amp;quot;);   Makefile  obj-m := hwm.o ifeq ($(KERNELRELEASE),) KERNELDIR ?</description>
    </item>
    
    <item>
      <title>Linux shared libraries</title>
      <link>https://daveixiang.github.io/articles/2016_04_02_linux_shared_libraries/</link>
      <pubDate>Sat, 02 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2016_04_02_linux_shared_libraries/</guid>
      <description>Shared libraries are collections of code that can be shared by programs. Unlike static (aka archive) libraries, they&amp;rsquo;re not part of the compiled program - they&amp;rsquo;re loaded in at the start of run-time if they&amp;rsquo;re not already being used. You don&amp;rsquo;t need to worry about them unless you&amp;rsquo;re a system manager or applications writer.
Every shared library has &amp;hellip; soname libname.so.version_number - the version number is incremented whenever the interface changes.</description>
    </item>
    
  </channel>
</rss>