<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 項 思 偉 (Davei) ~ Aal Izz Well!</title>
    <link>https://daveixiang.github.io/categories/linux/index.xml</link>
    <description>Recent content in Linux on 項 思 偉 (Davei) ~ Aal Izz Well!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="https://daveixiang.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Build minimal linux hack env with busybox (Target: x86_64)</title>
      <link>https://daveixiang.github.io/articles/2017_04_01_build_minimal_linux_hack_env_with_busybox_x86_64/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_04_01_build_minimal_linux_hack_env_with_busybox_x86_64/</guid>
      <description>

&lt;h2 id=&#34;build-the-kernel&#34;&gt;Build the kernel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use x86_64 default configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Simplify x86_64 configuration by cutting unused drivers&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Create Image&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-busybox&#34;&gt;Build busybox&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use busybox default configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Customize configurations&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Busybox Settings  ---&amp;gt;
  --- Build Options
  [*]   Build BusyBox as a position independent executable
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Create busybox&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- -j$(nproc)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Install busybox(default path: BUSYBOX/_install)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-minimal-initramfs&#34;&gt;Generate minimal initramfs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/bash
ROOTFS=rootfs
BUSYBOX=$(find busybox* -maxdepth 0 -type d)
SYSROOT=$(x86_64-linux-gnu-gcc --print-sysroot)
DYNAMIC_LIB_PATH_32=${SYSROOT}/lib
DYNAMIC_LIB_PATH_64=${SYSROOT}/lib64

rm -rf $ROOTFS
mkdir -p ${ROOTFS}/{proc,sys,dev,etc,etc/init.d,lib,lib64,mnt}

cat &amp;gt; $ROOTFS/etc/init.d/rcS &amp;lt;&amp;lt;EOF
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
ifconfig lo up
EOF

chmod +x $ROOTFS/etc/init.d/rcS

cat &amp;gt; $ROOTFS/etc/inittab &amp;lt;&amp;lt;EOF
# /etc/inittab
::sysinit:/etc/init.d/rcS
::askfirst:-/bin/sh
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
EOF

chmod +x $ROOTFS/etc/inittab

cp -rP ${BUSYBOX}/_install/* ${ROOTFS}

cp -rP ${DYNAMIC_LIB_PATH_64}/libc-2.25.so ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/libc.so.6 ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/libm-2.25.so ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/libm.so.6 ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/ld-2.25.so ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/ld-linux-x86-64.so.2 ${ROOTFS}/lib64/

cd ${ROOTFS}
ln -sf bin/busybox init
find . | cpio -o --format=newc &amp;gt; ../initramfs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-the-kernel-and-initramfs-just-built&#34;&gt;Test the kernel and initramfs just built&lt;/h2&gt;

&lt;p&gt;Use qemu to test the Image and initramfs which we just builded:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;qemu-system-x86_64  -nographic \
-kernel ./bzImage -initrd ./initramfs -append  &amp;quot;console=ttyS0 quiet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output just like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Please press Enter to activate this console. 
/ # ls
bin      etc      lib      linuxrc  proc     sbin     usr
dev      init     lib64    mnt      root     sys
/ #
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Add OpenSuse Leap 42.2 repos</title>
      <link>https://daveixiang.github.io/articles/2017_03_31_opensuse_add_repos/</link>
      <pubDate>Fri, 31 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_31_opensuse_add_repos/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Remove previous repos&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;zypper repos | grep Yes | cut -f3 -d &#39;|&#39; | sed -e &amp;quot;s/ //&amp;quot; | awk &#39;{print &amp;quot;zypper rr &amp;quot; $1}&#39; | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Add the repos and refresh&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;zypper addrepo -f http://mirrors4.tuna.tsinghua.edu.cn/opensuse/distribution/leap/42.2/repo/oss/ openSUSE-leap-42.2-Oss
zypper addrepo -f http://mirrors4.tuna.tsinghua.edu.cn/opensuse/distribution/leap/42.2/repo/non-oss/ openSUSE-leap-42.2-Non-Oss
zypper addrepo -f http://mirrors4.tuna.tsinghua.edu.cn/opensuse/update/leap/42.2/oss openSUSE-leap-42.2-Update-Oss
zypper addrepo -f http://mirrors4.tuna.tsinghua.edu.cn/opensuse/update/leap/42.2/non-oss/ openSUSE-leap-42.2-Update-Non-Oss

zypper refresh
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Notation meaning in top out</title>
      <link>https://daveixiang.github.io/articles/2017_03_30_notation_meaning_in_top_out/</link>
      <pubDate>Thu, 30 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_03_30_notation_meaning_in_top_out/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;PID — Process Id&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The task’s unique process ID, which periodically wraps, though
never restarting at zero.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;PPID — Parent Process Pid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The process ID of a task’s parent.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;RUSER — Real User Name&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The real user name of the task’s owner.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;UID — User Id&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The effective user ID of the task’s owner.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;USER — User Name&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The effective user name of the task’s owner.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;GROUP — Group Name&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The effective group name of the task’s owner.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TTY — Controlling Tty&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The name of the controlling terminal. This is usually the
device (serial port, pty, etc.) from which the process was
started, and which it uses for input or output. However, a
task need not be associated with a terminal, in which case
you’ll see ‘?’ displayed.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;PR — Priority&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The priority of the task.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;NI — Nice value&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The nice value of the task. A negative nice value means higher
priority, whereas a positive nice value means lower priority.
Zero in this field simply means priority will not be adjusted
in determining a task’s dispatchability.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;P — Last used CPU (SMP)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A number representing the last used processor. In a true SMP
environment this will likely change frequently since the kernel
intentionally uses weak affinity. Also, the very act of
running top may break this weak affinity and cause more
processes to change CPUs more often (because of the extra
demand for cpu time).
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;%CPU — CPU usage&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The task’s share of the elapsed CPU time since the last screen
update, expressed as a percentage of total CPU time. In a true
SMP environment, if ‘Irix mode’ is Off, top will operate in
‘Solaris mode’ where a task’s cpu usage will be divided by the
total number of CPUs. You toggle ‘Irix/Solaris’ modes with the
‘I’ interactive command.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TIME — CPU Time&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Total CPU time the task has used since it started. When
‘Cumulative mode’ is On, each process is listed with the cpu
time that it and its dead children has used. You toggle
‘Cumulative mode’ with ‘S’, which is a command-line option and
an interactive command. See the ‘S’ interactive command for
additional information regarding this mode.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;TIME+ — CPU Time, hundredths&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The same as ‘TIME’, but reflecting more granularity through
hundredths of a second.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;%MEM — Memory usage (RES)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A task’s currently used share of available physical memory.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;VIRT — Virtual Image (kb)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The total amount of virtual memory used by the task. It
includes all code, data and shared libraries plus pages that
have been swapped out and pages that have been mapped but not
used.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;SWAP — Swapped size (kb)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Memory that is not resident but is present in a task. This is
memory that has been swapped out but could include additional
non-resident memory. This column is calculated by subtracting
physical memory from virtual memory.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;RES — Resident size (kb)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The non-swapped physical memory a task has used.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CODE — Code size (kb)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The amount of virtual memory devoted to executable code, also
known as the ‘text resident set’ size or TRS.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;DATA — Data+Stack size (kb)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The amount of virtual memory devoted to other than executable
code, also known as the ‘data resident set’ size or DRS.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;SHR — Shared Mem size (kb)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The amount of shared memory used by a task. It simply reflects
memory that could be potentially shared with other processes.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;nFLT — Page Fault count&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The number of major page faults that have occurred for a task.
A page fault occurs when a process attempts to read from or
write to a virtual page that is not currently present in its
address space. A major page fault is when backing storage
access (such as a disk) is involved in making that page
available.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;nDRT — Dirty Pages count&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The number of pages that have been modified since they were
last written to disk. Dirty pages must be written to disk
before the corresponding physical memory location can be used
for some other virtual page.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;S — Process Status&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;The status of the task which can be one of:
‘D’ = uninterruptible sleep
‘R’ = running
‘S’ = sleeping
‘T’ = traced or stopped
‘Z’ = zombie
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Build minimal linux hack env ith busybox (Target: arm64)</title>
      <link>https://daveixiang.github.io/articles/2017_02_25_build_minimal_linux_hack_env_with_busybox_arm64/</link>
      <pubDate>Sat, 25 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_25_build_minimal_linux_hack_env_with_busybox_arm64/</guid>
      <description>

&lt;h2 id=&#34;build-the-kernel&#34;&gt;Build the kernel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use arm64 default configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Simplify arm64 configuration by cutting unused drivers&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Create Image&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-busybox&#34;&gt;Build busybox&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use busybox default configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Customize configurations&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Busybox Settings  ---&amp;gt;
  --- Build Options
  [*]   Build BusyBox as a position independent executable
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Create busybox&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Install busybox(default path: BUSYBOX/_install)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-minimal-initramfs&#34;&gt;Generate minimal initramfs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/bash
ROOTFS=rootfs
BUSYBOX=$(find busybox* -maxdepth 0 -type d)
SYSROOT=$(aarch64-linux-gnu-gcc --print-sysroot)
DYNAMIC_LIB_PATH_32=${SYSROOT}/lib
DYNAMIC_LIB_PATH_64=${SYSROOT}/lib64

rm -rf $ROOTFS
mkdir -p ${ROOTFS}/{proc,sys,dev,etc,etc/init.d,lib,lib64,mnt}

cat &amp;gt; $ROOTFS/etc/init.d/rcS &amp;lt;&amp;lt;EOF
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
ifconfig lo up
EOF

chmod +x $ROOTFS/etc/init.d/rcS

cat &amp;gt; $ROOTFS/etc/inittab &amp;lt;&amp;lt;EOF
# /etc/inittab
::sysinit:/etc/init.d/rcS
::askfirst:-/bin/sh
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
EOF

chmod +x $ROOTFS/etc/inittab

cp -rP ${BUSYBOX}/_install/* ${ROOTFS}

cp -rP ${DYNAMIC_LIB_PATH_64}/libc-2.25.so ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/libc.so.6 ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/libm-2.25.so ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/libm.so.6 ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_64}/ld-2.25.so ${ROOTFS}/lib64/
cp -rP ${DYNAMIC_LIB_PATH_32}/ld-linux-aarch64.so.1 ${ROOTFS}/lib/

cd ${ROOTFS}
ln -sf bin/busybox init
find . | cpio -o --format=newc &amp;gt; ../initramfs
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;test-the-kernel-and-initramfs-just-built&#34;&gt;Test the kernel and initramfs just built&lt;/h1&gt;

&lt;p&gt;Use qemu to test the Image and initramfs which we just builded:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;qemu-system-aarch64 -machine virt -cpu cortex-a57 \
-kernel ./Image -initrd ./initramfs -nographic -append &amp;quot;console=ttyAMA0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output just like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Please press Enter to activate this console. 
/ # ls
bin      etc      lib      linuxrc  proc     sbin     usr
dev      init     lib64    mnt      root     sys
/ #
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Using OpenvSwitch to build minimal linux networking hack environment</title>
      <link>https://daveixiang.github.io/articles/2017_02_25_using_openvswitch_to_build_minimal_linux_networking_hack_env/</link>
      <pubDate>Sat, 25 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_25_using_openvswitch_to_build_minimal_linux_networking_hack_env/</guid>
      <description>

&lt;h2 id=&#34;prepare-two-minimal-vms&#34;&gt;Prepare two minimal vms&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p vm01 vm02

cp -a  Image initramfs  vm01

cp -a  Image initramfs  vm02
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-openvswitch-bridge-and-two-tap-devices-for-vm&#34;&gt;Create Openvswitch bridge and two tap devices for vm&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ip tuntap add name tap1 mode tap
ip tuntap add name tap2 mode tap

ip link set tap1 up
ip link set tap2 up

ovs-vsctl add-br br0

ovs-vsctl add-port br0 tap1

ovs-vsctl add-port br0 tap2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;start-the-two-vms-and-config-network&#34;&gt;Start the two vms and config network&lt;/h2&gt;

&lt;h3 id=&#34;configure-vm01&#34;&gt;configure vm01&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;start vm01&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd vm01

qemu-system-x86_64  -nographic \
-kernel ./bzImage -initrd ./initramfs \
-append  &amp;quot;console=ttyS0 quiet&amp;quot; \
-netdev tap,id=net1,ifname=tap1,script=no,downscript=no  \
-device e1000,netdev=net1,mac=&#39;9e:11:24:5c:35:89&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;configure vm01 network&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ip link set eth0 up
ip addr add 192.168.0.1/24 dev eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configure-vm02&#34;&gt;configure vm02&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;start vm02&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd vm02

qemu-system-x86_64  -nographic \
-kernel ./bzImage -initrd ./initramfs \
-append  &amp;quot;console=ttyS0 quiet&amp;quot; \
-netdev tap,id=net2,ifname=tap2,script=no,downscript=no  \
-device e1000,netdev=net2,mac=&#39;66:5f:30:f4:24:be&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;configure vm02 network&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ip link set eth0 up
ip addr add 192.168.0.2/24 dev eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-the-vms-network-connection&#34;&gt;Test the vms network connection&lt;/h2&gt;

&lt;p&gt;vm01 ping vm02&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ping 192.168.0.2
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>What is a system call (Linux)</title>
      <link>https://daveixiang.github.io/articles/2017_02_02_what_is_a_system_call_linux/</link>
      <pubDate>Thu, 02 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2017_02_02_what_is_a_system_call_linux/</guid>
      <description>

&lt;p&gt;An application program makes a system call to get the operating
system to perform a service for it, like reading from a file.&lt;/p&gt;

&lt;h1 id=&#34;system-calls-in-32-bit-linux&#34;&gt;System Calls in 32-bit Linux&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To make a system call in &lt;strong&gt;32-bit&lt;/strong&gt; Linux, place the system call number
in eax, then its arguments, in order, in &lt;strong&gt;ebx&lt;/strong&gt;, &lt;strong&gt;ecx&lt;/strong&gt;, &lt;strong&gt;edx&lt;/strong&gt;,
&lt;strong&gt;esi&lt;/strong&gt;, &lt;strong&gt;edi&lt;/strong&gt;, and &lt;strong&gt;ebp&lt;/strong&gt;, then invoke &lt;strong&gt;int 0x80&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Some system calls return information, usually in &lt;strong&gt;eax&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;All registers are saved across the system call.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.section .data
mesg:
    .asciz &amp;quot;Hello World\n&amp;quot;
mesg_len = . - mesg

.section .text
.global _start
_start:                         # ELF entry point
    mov $4, %eax                # sys_write
    mov $1, %ebx                # STDOUT
    mov $mesg, %ecx             # buffer address
    mov $mesg_len, %edx         # buffer length
    int $0x80

    mov $1, %eax                # sys_exit
    mov $0, %ebx                # error code
    int $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;system-calls-in-64-bit-linux&#34;&gt;System Calls in 64-bit Linux&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To make a system call in &lt;strong&gt;64-bit&lt;/strong&gt; Linux, place the system call
number in &lt;strong&gt;rax&lt;/strong&gt;, then its arguments, in order, in &lt;strong&gt;rdi&lt;/strong&gt;,
&lt;strong&gt;rsi&lt;/strong&gt;, &lt;strong&gt;rdx&lt;/strong&gt;, &lt;strong&gt;r10&lt;/strong&gt;, &lt;strong&gt;r8&lt;/strong&gt;, and &lt;strong&gt;r9&lt;/strong&gt;, then invoke syscall.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Some system calls return information, usually in &lt;strong&gt;rax&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The system call destroys &lt;strong&gt;rcx&lt;/strong&gt; and &lt;strong&gt;r11&lt;/strong&gt; but others registers
are saved across the system call.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;code 01&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.section .data
mesg:
    .asciz &amp;quot;Hello World\n&amp;quot;
mesg_len = . - mesg

.section .text
.global _start
_start:                         # ELF entry point
    mov $1, %rax                # sys_write
    mov $1, %rdi                # STDOUT
    mov $mesg, %rsi             # buffer address
    mov $mesg_len, %rdx         # buffer length
    syscall
    mov %rax, %rbx

    mov $60, %rax               # sys_exit
    mov %rbx, %rdi              # 0
    syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code 02&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.data
_hello:
  .asciz &amp;quot;hello world\n&amp;quot;

.text
.globl _main
_main:
  subq $8, %rsp

  movb $0, %al
  leaq _hello(%rip), %rdi
  call _printf

  movq $0, %rdi
  call _exit
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Add Module to the Linux Kernel Source</title>
      <link>https://daveixiang.github.io/articles/2016_04_21_add_module_to_the_linux_kernel_source/</link>
      <pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2016_04_21_add_module_to_the_linux_kernel_source/</guid>
      <description>

&lt;h1 id=&#34;create-module-directory&#34;&gt;Create module directory&lt;/h1&gt;

&lt;p&gt;Create a directory &lt;em&gt;skm&lt;/em&gt; inside &lt;em&gt;drivers&lt;/em&gt; (which is in the Linux
source code) for your module and put source code(skm.c) into it. It
will looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;{LINUX_SRC_PATH}/drivers/skm/skm.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the source code file skm.c appears like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/version.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;

static int __init skm_init(void)
{
        printk(KERN_INFO &amp;quot;Hello Kernel Space!\n&amp;quot;);

        return 0;
}

static void __exit skm_exit(void)
{
        printk(KERN_INFO &amp;quot;Bye Kernel Space!\n&amp;quot;);
}

module_init(skm_init);
module_exit(skm_exit);

MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
MODULE_AUTHOR(&amp;quot;Xiang Davei&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;Simple Kernel Module&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;create-makefile-file&#34;&gt;Create &lt;em&gt;Makefile&lt;/em&gt; file&lt;/h1&gt;

&lt;p&gt;Create one &lt;em&gt;Makefile&lt;/em&gt; inside &lt;em&gt;skm&lt;/em&gt; and add &lt;em&gt;obj-$(CONFG_SKM) += skm.o&lt;/em&gt;
to it. This will appears like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;obj-$(CONFIG_SKM) += skm.o
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;create-kconfig-file&#34;&gt;Create &lt;em&gt;Kconfig&lt;/em&gt; file&lt;/h1&gt;

&lt;p&gt;Create one &lt;em&gt;Kconfig&lt;/em&gt; inside &lt;em&gt;skm&lt;/em&gt; , then put the content as the
following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;config SKM
        tristate &amp;quot;simple kernel module&amp;quot;
        default y
        help
          simple kernel module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into it. And it will looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;{LINUX_SRC_PATH}/drivers/skm/Kconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;edit-makefile-and-kconfig-in-linux-src-path-drivers&#34;&gt;Edit &lt;em&gt;Makefile&lt;/em&gt; and &lt;em&gt;Kconfig&lt;/em&gt; in &lt;em&gt;{LINUX_SRC_PATH}/drivers/&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;In the &lt;em&gt;Makefile&lt;/em&gt; add below in last line&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;obj-y += skm/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;obj-$(CONFIG_SKM) += skm/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Kconfig file add below in last line&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;source &amp;quot;drivers/my_drvr/Kconfig&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;compile-the-source-code-with-module-just-added&#34;&gt;Compile the source code with module just added&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;em&gt;make menuconfig&lt;/em&gt; to choice the module just added&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=i386 CROSS_COMPILE=i686-none-linux- menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Device Drivers  ---&amp;gt;
    &amp;lt;M&amp;gt; simple kernel module
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;em&gt;make -j$(nproc)&lt;/em&gt; to compile the kernel&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make ARCH=i386 CROSS_COMPILE=i686-none-linux- -j$(nproc)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;em&gt;make modules_install&lt;/em&gt; to install the kernel modules&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make modules_install INSTALL_MOD_PATH=${MODULES_PATH}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;load the &lt;em&gt;skm&lt;/em&gt; into the kernel&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;modprobe skm

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;get the module information&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;modinfo skm
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;unload the module from the kernel&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;modprobe -r skm
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux Hello World Module</title>
      <link>https://daveixiang.github.io/articles/2016_04_20_linux_helloworld_module/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://daveixiang.github.io/articles/2016_04_20_linux_helloworld_module/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Source Code&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;

static __init int hwm_init(void)
{
        /* do_this() */
        /* do_that() */
        /* do_something_else() */

        printk(KERN_INFO &amp;quot;hwm module being loaded\n&amp;quot;);
        return 0;
}

static __exit void hwm_exit(void)
{
        /* undo_something_else() */
        /* undo_that() */
        /* undo_this() */

        printk(KERN_INFO &amp;quot;hwm module being unloaded\n&amp;quot;);
}

module_init(hwm_init);
module_exit(hwm_exit);

MODULE_AUTHOR(&amp;quot;davei&amp;quot;);
MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;Hello World Module&amp;quot;);
MODULE_INFO(flavor, &amp;quot;Linux&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Makefile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;obj-m := hwm.o

ifeq ($(KERNELRELEASE),)  

KERNELDIR ?= /lib/modules/$(shell uname -r)/build 
PWD := $(shell pwd)  

all:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules  
clean:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) clean
else  

$(info Building with KERNELRELEASE = ${KERNELRELEASE})  

endif
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Module Information&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Execute the command to get the module information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;modinfo hwm.ko
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;filename:       /root/modules/hwm/hwm.ko
flavor:         Linux
description:    Hello World Module
license:        GPL
author:         davei
srcversion:     CF3FE4016436A4A53352A88
depends:        
vermagic:       4.1.15 SMP mod_unload modversions
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>